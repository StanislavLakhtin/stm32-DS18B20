# DS18B20 libopencm3 OneWire library для stm32

Проверка осуществлялась на stm32f103c8t6, однако, список оддерживаемых устройства должен быть намного шире. Фактически не использовался
никакой, специфичный именно для stm32f1, код.

## Описание библиотеки

Библиотека разработана для работы с широко распространёнными датчиками температуры Maxim (Dallas) DS18B20
по протоколу OneWire.

В качестве основы реализации была выбрана библиотека libopencm3.
libopencm3 является очень удачной основой для программирования на stm32, однако, в связи с плохой документацией
является слегка недооценённой со стороны хобистов. Получающийся код получается легко читаемым, компактным и эффективным, по сравнению с 
SPL и HAL от ST Microelectronics.

Библитека OneWire реализует SKIP, SEARCH, MATCH, READ, READ SCRATCHPAD, CONVERT TEMPERATURE, RECALL E2 и др.  команды и работает на микроконтроллере 
stm32f103c8t6 и, вероятнее всего, массе других.

Библиотека предполагает подключение датчиков (до 75 на одной линии) к любому из выходов TX USART/UART. Предполагается наличие 
внешнее питание датчиков и подтяжка DATA линии к линии питания сопротивлением с номиналом, соответствующим задаче 
(по-умолчанию 4.7K). Режим работы USART/UART в данном случае полудуплексный. В распоряжении разработчика остаётся свободный(е) gpio.

Предполагается использование аппаратного USART/UART. Билиотека должна неплохо работать в составе RTOS, потому что, фактически, все критичные 
операции сделаны атомарными.

Библиотека позволяет организовать 5 независимых шин OneWire (по количеству аппаратной поддержки USART/UART). Количество устройств на шине определятеся 
разработчиком. В режиме "по умолчанию" ожидается до 5 устройств на шине. 

Проект собирается на Clion на любой ОС (Mac OS X, Windows, Linux) + arm-none-eabi + cmake. Отладка осуществлялась blackmagic probe и .gdbinit
соответствует инициализации процесса подключения.

## Немного о датчике 

Датчик DS18B20, равно как и DS18S20, относится к классу устройств, назначение и работа которых требует пояснения.

Во-первых, эти датчики обладают собственной памятью, настройками и логикой работы. Их взаимодействие с uK осуществляется на основании возможных протоколов взаимодействия.
В процессе подготовки новых данных датчик потребляет довольно много электроэнергии (до 1.5mA) и поэтому не осуществляет замер непрерывно.
Поэтому, последнее сделанное им измерение не означает "текущую температуру". Разумно предположить, что пока датчику отослана команда на 
измерение температуры, микроконтроллер должен быть занят чем-то полезным (или сном), вместо простого ожидания готовности сенсора.

Во-вторых, датчик умеет довольно много кроме измерения температуры. Так, например, датчик умеет устанавливать границы "тревоги" и в ответ на 
специальный запрос сообщать о том, что температура вышла за эти пределы. Это может быть полезно, например, для такого сценария:
размещение группы датчиков по территории (например, вдоль стены), одновременная посылка запроса на измерение температуры, а после, команды на 
определение тех датчиков, измеренная темпетарута которых выходит за установленные ранее пределы. Соотвественно опрос потом не всех датчиков, 
а лишь тех, которые сформировали "тревогу".

Кроме этого, эти два байта датчика (устанавливающие границы тревоги) могут использовать произвольным образом для сохранения какой-то информации, которая может быть сохранена 
в EEPROM датчика и использоваться позднее.

Понятно, что эти датчики предназначены для очень удалённого размещения от uK. Его удалённость может составлять десятки метров 
(реально метров до 30).


## Структура программы

Предположим, что шина OneWire будет реализовываться на USART3 синей таблетки (bluepile) stm32f103c8t6, очень дешевой и доступной плате для экспериментов.
Библиотека использует соответствующее прерывание(я), чтобы организовать чтение RX в момент передачи в линию по TX. Напоминает создание 
loopback на UART. 

Поэтому следует объявить:

```C
// Должно быть объявлено ДО include "OneWire.h", чтобы был добавлен обработчик соответствующего прерывания
//#define ONEWIRE_UART5
//#define ONEWIRE_UART4
#define ONEWIRE_USART3 
//#define ONEWIRE_USART2
//#define ONEWIRE_USART1

//максимальное количество устройств на шине по-умолчанию
//MAXDEVICES_ON_THE_BUS 5 

#include "OneWire.h"
```

Для того, чтобы использовать библиотеку следует инициализировать "часы" в `static void clock_setup(void)`: 

```C
    gpio_set_mode(GPIOB, GPIO_MODE_OUTPUT_10_MHZ,
                  GPIO_CNF_OUTPUT_ALTFN_OPENDRAIN, GPIO_USART3_TX | GPIO_USART3_RX);
```

После, настроить gpio в `static void gpio_setup(void)`:

```C
    gpio_set_mode(GPIOB, GPIO_MODE_OUTPUT_10_MHZ,
                  GPIO_CNF_OUTPUT_ALTFN_OPENDRAIN, GPIO_USART3_TX | GPIO_USART3_RX);

```

И объявить (локальную или глобальную -- как удобнее) переменную, которая будет хранить сведения об устройствах на шине:

```C
OneWire ow;
```

Если Вы хотите увеличить/уменьшить количество устройств о которых будет сохранена информация по умолчанию самостоятельно определите ДО 
подключения OneWire.h `MAXDEVICES_ON_THE_BUS`

После этого всё готово к использованию.
